(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{591:function(e,t,r){"use strict";r.r(t);var v=r(13),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("p",[e._v("new Promise(function(resolve,reject){")]),e._v(" "),r("p",[e._v("​\t\tresolve()   //只能传递一个参数")]),e._v(" "),r("p",[e._v("}).then(function(){")]),e._v(" "),r("p",[e._v("}).catch(function{")]),e._v(" "),r("p",[e._v("})")]),e._v(" "),r("p",[e._v("状态机三种：pending，fulfilled，rejected；默认是pending")]),e._v(" "),r("p",[e._v("​\t\t当执行resolve函数时，状态被修改为fulfilled状态，这时候，如果再执行reject函数，判断当前状态是否是pending，如果不是pending状态就不再执行reject函数。")]),e._v(" "),r("p",[e._v("​\t\t如果当前状态是pending状态，执行了reject函数时，状态被修改为rejected状态，再次执行resolve方法，发现状态不是pending状态，就会跳出不再执行resolve函数。")]),e._v(" "),r("p",[e._v("​\t\t在Promise中，只能执行一次resolve或者一次reject")]),e._v(" "),r("p",[e._v("不管开始执行的是哪一种方式，执行后都会返回一个新的状态为fulfilled状态的Promise默认没有返回值时。")]),e._v(" "),r("p",[e._v("连续catch不被触发，连续then会被连续触发")]),e._v(" "),r("h5",{attrs:{id:"静态方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[e._v("#")]),e._v(" 静态方法：")]),e._v(" "),r("p",[e._v("Promise.all()：将Promise对象的数组按照顺序从前向后全部执行完成，然后将每一次resolve传出的结果放在一个新数组中，并且将其在then中的函数中返回。")]),e._v(" "),r("p",[e._v("Promise.race()：查看谁的异步先完成就先返回谁。")]),e._v(" "),r("p",[e._v("Promise.resolve()：等同于：new Promise(function(resolve,reject){resolve()})")]),e._v(" "),r("p",[e._v("Promise.reject()：等同于：new Promise(function(resolve,reject){reject()})")]),e._v(" "),r("h4",{attrs:{id:"async和await"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#async和await"}},[e._v("#")]),e._v(" async和await")]),e._v(" "),r("p",[e._v("阻塞式同步")]),e._v(" "),r("p",[e._v("async函数执行后将返回一个Promise对象")]),e._v(" "),r("p",[e._v("async function fn(){return 1}")]),e._v(" "),r("p",[e._v("fn.then((res)=>{console.log(res)}) //1")]),e._v(" "),r("p",[e._v("await必须写在async函数里面")]),e._v(" "),r("p",[e._v("await等待调用resolve（）之后再往下执行。")]),e._v(" "),r("p",[e._v("await只等待promise中的resolve函数执行，其他不会等待。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
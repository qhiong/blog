(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{582:function(t,i,e){"use strict";e.r(i);var n=e(13),a=Object(n.a)({},(function(){var t=this,i=t.$createElement,e=t._self._c||i;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[t._v("#")]),t._v(" git")]),t._v(" "),e("h3",{attrs:{id:"git的下载和安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git的下载和安装"}},[t._v("#")]),t._v(" git的下载和安装")]),t._v(" "),e("p",[t._v("​\twindows的下载\n创建远程个gitHub仓库\n​\t打开gitHub网站\n​\t\thttps://github.com/\n​\t注册gitHub会员\n​\t\t点击Sign Up\n​\t\t填写用户名，邮箱，密码。填写完成点击Create an account\n​\t\t选择第一个免费，Unlimited public repositories for free.然后点击Continue\n​\t创建新仓库\n​\t\t点击顶部右侧头像图标按钮左边的加号\n​\t\t\tnew repository\n​\t\t填写仓库名称\n​\t\t\tRepository name\n​\t\t填写仓库描述（可选）\n​\t\t\tDescription\n​\t选择仓库是否公开\n​\t\tpublic 公有的，大家都能看到\n​\t\tprivate 私有的，仅自己可以看到\n​\t初始化仓库的介绍文件\n​\t\tInitialize this repository with a README\n​\t点击创建\n​\t获取创建好的仓库地址\n​\t\thttps地址\n​\t\t\thttps://github.com/用户名/仓库名.git\n​\t\tSSH地址\n​\t\t\tgit@github.com:用户名/仓库名.git")]),t._v(" "),e("h3",{attrs:{id:"git创建本地版本库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git创建本地版本库"}},[t._v("#")]),t._v(" git创建本地版本库")]),t._v(" "),e("p",[t._v('​\t打开windows菜单下安装好的git下的gitBush\n​\t修改当前盘符和路径\n​\t\tcd /盘符/目录\n​\t创建新目录\n​\t\t可以用windows下的方法创建\n​\t\tgit创建方法  mkdir 文件夹名称\n​\t显示目录\n​\t\t显示当前目录 pwd\n​\t把当前目录设置为本地仓库\n​\t\tgit init\n​\t设置当前公用的用户名和邮件地址\n​\t\tgit config --global user.name "gitHub上注册的用户名"\n​\t\tgit config --global user.email “gitHub上注册时用的邮箱”\n​\t设置SSH的Key\n​\t\tssh-keygen -t rsa -C "gitHub上注册时用的邮箱"\n​\t\tGenerating public/private rsa key pair.(/Users/your_user_directory/.ssh/id_rsa)直接敲回车\n​\t\tEnter passphrase (empty for no passphrase):'),e("enter",{attrs:{a:"",passphrase:""}},[t._v("  直接敲回车\n​\t\tEnter same passphrase again:"),e("enter",{attrs:{passphrase:"",again:""}},[t._v("直接敲回车\n​\t\t生成类似于下面的内容\n+--[ RSA 2032]----+"),e("br"),t._v("\n|     .+   +      |"),e("br"),t._v("\n|      ssssssss   |"),e("br"),t._v("\n|        = * *    |"),e("br"),t._v("\n|       o = +     |"),e("br"),t._v("\n|     ssss .      |"),e("br"),t._v("\n|     o oss       |"),e("br"),t._v("\n|      o .sE      |"),e("br"),t._v("\n|                 |"),e("br"),t._v("\n|                 |"),e("br"),t._v("\n+-----------------+"),e("br"),t._v("\n​\t\t打开我的电脑--》用户---》当前登录Windows的用户名文件夹----》.ssh文件夹-----》用记事本打开id_rsa.pub文件----》复制里面的内容\n​\t\t打开gitHub官网，登陆，选择进入创建的项目，选择右边的settings选项\n​\t\t选择Deploy keys\n​\t\t\t点击add deploy key 添加key\n​\t\ttitle填写用户名称+SSHkey，然后把刚才复制的内容直接粘贴到key里面，不要敲任何其他的按钮，点选Allow write access。然后点击add key。创建完成SSH的Key了")])],1)],1),t._v(" "),e("h3",{attrs:{id:"上传项目到仓库中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上传项目到仓库中"}},[t._v("#")]),t._v(" 上传项目到仓库中")]),t._v(" "),e("p",[t._v('​\t创建一个文件\n​\t\t在刚才新建的本地仓库中创建一个文件，例如:ReadMe.txt\n​\t\t在gitBush窗口中输入：git add ReadMe.txt\n​\t告诉git要提交到仓库，并且添加注释\n​\t\tgit commit -m "注释内容"\n​\t连接gitHub仓库地址\n​\t\tgit remote add origin 刚才复制的地址\n​\t上传到gitHub服务器\n​\t\tgit push -u origin master\n​\t取回远程仓库的变化，并与本地分支合并\n​\t\tgit pull origin master\n​\t错误提示\n​\t\tPermission denied (publickey).'),e("br"),t._v("\nfatal: The remote end hung up unexpectedly\n​\t\t\t这是没有权限，如果上一步中git创建版本库中设置ssh的key没有完成或者错误。\n​\t\t\t\tcd ~/.ssh\n​\t\t\t\trm id_rsa*\n​\t\t\t\t设置SSH的Key\n​\t\tfailed to push some refs to git\n​\t\t\t这是因为gitHub创建时可能创建了README.md，但是版本没有合并\n​\t\t\t\tgit pull --rebase origin master\n​\t\t\t\t然后做后续的操作就可以了\n​\t\tremote origin already exists\n​\t\t\t创建连接时提示，这是因为已经有了仓库，需要先删除远程仓库，git remote rm origin\n​\t\tgit push时报错fatal: Could not read from remote repository.\n​\t\t\t设置的地址应该为https的，需要修改一下\n​\t\t\t\tgit remote set-url origin XXX")]),t._v(" "),e("h3",{attrs:{id:"从github仓库下载项目到本地仓库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从github仓库下载项目到本地仓库"}},[t._v("#")]),t._v(" 从gitHub仓库下载项目到本地仓库")]),t._v(" "),e("p",[t._v("​\t自己创建的项目库\n​\t\tgit clone git@github.com:用户名/仓库名.git\n​\t别人创建好的项目\n​\t\t点击右上角的Fork，表示先复制到自己的仓库里\n​\t\tgit clone git@github.com:用户名/仓库名.git")]),t._v(" "),e("h3",{attrs:{id:"git所有命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git所有命令"}},[t._v("#")]),t._v(" git所有命令")]),t._v(" "),e("h5",{attrs:{id:"一、新建代码库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、新建代码库"}},[t._v("#")]),t._v(" 一、新建代码库")]),t._v(" "),e("p",[t._v("​\t\t# 在当前目录新建一个Git代码库\n​\t\t\t$ git init\n​\t\t# 新建一个目录，将其初始化为Git代码库\n​\t\t\t$ git init [project-name]\n​\t\t# 下载一个项目和它的整个代码历史\n​\t\t\t$ git clone [url]")]),t._v(" "),e("h5",{attrs:{id:"二、配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、配置"}},[t._v("#")]),t._v(" 二、配置")]),t._v(" "),e("p",[t._v('​\t\tGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n​\t\t# 显示当前的Git配置\n​\t\t\t$ git config --list\n​\t\t# 编辑Git配置文件\n​\t\t\t$ git config -e [--global]\n​\t\t# 设置提交代码时的用户信息\n​\t\t\t$ git config [--global] user.name "[name]"\n​\t\t\t$ git config [--global] user.email "[email address]"')]),t._v(" "),e("h5",{attrs:{id:"三、增加-删除文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、增加-删除文件"}},[t._v("#")]),t._v(" 三、增加/删除文件")]),t._v(" "),e("p",[t._v("添加指定文件到暂存区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git add [file1] [file2] ...")]),t._v(" "),e("p",[t._v("添加指定目录到暂存区，包括子目录")]),t._v(" "),e("p",[t._v("​\t\t\t$ git add [dir]")]),t._v(" "),e("p",[t._v("添加当前目录的所有文件到暂存区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git add .")]),t._v(" "),e("p",[t._v("添加每个变化前，都会要求确认")]),t._v(" "),e("p",[t._v("对于同一个文件的多处变化，可以实现分次提交")]),t._v(" "),e("p",[t._v("​\t\t\t$ git add -p")]),t._v(" "),e("p",[t._v("删除工作区文件，并且将这次删除放入暂存区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git rm [file1] [file2] ...")]),t._v(" "),e("p",[t._v("停止追踪指定文件，但该文件会保留在工作区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git rm --cached [file]")]),t._v(" "),e("p",[t._v("改名文件，并且将这个改名放入暂存区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git mv [file-original] [file-renamed]")]),t._v(" "),e("h5",{attrs:{id:"四、代码提交"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、代码提交"}},[t._v("#")]),t._v(" 四、代码提交")]),t._v(" "),e("p",[t._v("提交暂存区到仓库区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit -m [message]")]),t._v(" "),e("p",[t._v("提交暂存区的指定文件到仓库区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit [file1] [file2] ... -m [message]")]),t._v(" "),e("p",[t._v("提交工作区自上次commit之后的变化，直接到仓库区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit -a")]),t._v(" "),e("p",[t._v("提交时显示所有diff信息")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit -v")]),t._v(" "),e("p",[t._v("使用一次新的commit，替代上一次提交")]),t._v(" "),e("p",[t._v("如果代码没有任何新变化，则用来改写上一次commit的提交信息")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit --amend -m [message]")]),t._v(" "),e("p",[t._v("重做上一次commit，并包括指定文件的新变化")]),t._v(" "),e("p",[t._v("​\t\t\t$ git commit --amend [file1] [file2] ...")]),t._v(" "),e("h5",{attrs:{id:"五、分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五、分支"}},[t._v("#")]),t._v(" 五、分支")]),t._v(" "),e("p",[t._v("​\t\t# 列出所有本地分支\n​\t\t\t$ git branch\n​\t\t# 列出所有远程分支\n​\t\t\t$ git branch -r\n​\t\t# 列出所有本地分支和远程分支\n​\t\t\t$ git branch -a\n​\t\t# 新建一个分支，但依然停留在当前分支\n​\t\t\t$ git branch [branch-name]\n​\t\t# 新建一个分支，并切换到该分支\n​\t\t\t$ git checkout -b [branch]\n​\t\t# 新建一个分支，指向指定commit\n​\t\t\t$ git branch [branch] [commit]\n​\t\t# 新建一个分支，与指定的远程分支建立追踪关系\n​\t\t\t$ git branch --track [branch] [remote-branch]\n​\t\t# 切换到指定分支，并更新工作区\n​\t\t\t$ git checkout [branch-name]\n​\t\t# 切换到上一个分支\n​\t\t\t$ git checkout -\n​\t\t# 建立追踪关系，在现有分支与指定的远程分支之间\n​\t\t\t$ git branch --set-upstream [branch] [remote-branch]\n​\t\t# 合并指定分支到当前分支\n​\t\t\t$ git merge [branch]\n​\t\t# 选择一个commit，合并进当前分支\n​\t\t\t$ git cherry-pick [commit]\n​\t\t# 删除分支\n​\t\t\t$ git branch -d [branch-name]\n​\t\t# 删除远程分支\n​\t\t\t$ git push origin --delete [branch-name]\n​\t\t\t$ git branch -dr [remote/branch]")]),t._v(" "),e("h5",{attrs:{id:"六、标签"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六、标签"}},[t._v("#")]),t._v(" 六、标签")]),t._v(" "),e("p",[t._v("列出所有tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git tag")]),t._v(" "),e("p",[t._v("新建一个tag在当前commit")]),t._v(" "),e("p",[t._v("​\t\t\t$ git tag [tag]")]),t._v(" "),e("p",[t._v("新建一个tag在指定commit")]),t._v(" "),e("p",[t._v("​\t\t\t$ git tag [tag] [commit]")]),t._v(" "),e("p",[t._v("删除本地tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git tag -d [tag]")]),t._v(" "),e("p",[t._v("删除远程tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push origin :refs/tags/[tagName]")]),t._v(" "),e("p",[t._v("查看tag信息")]),t._v(" "),e("p",[t._v("​\t\t\t$ git show [tag]")]),t._v(" "),e("p",[t._v("提交指定tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push [remote] [tag]")]),t._v(" "),e("p",[t._v("提交所有tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push [remote] --tags")]),t._v(" "),e("p",[t._v("新建一个分支，指向某个tag")]),t._v(" "),e("p",[t._v("​\t\t\t$ git checkout -b [branch] [tag]")]),t._v(" "),e("h5",{attrs:{id:"七、查看信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七、查看信息"}},[t._v("#")]),t._v(" 七、查看信息")]),t._v(" "),e("p",[t._v('​\t\t# 显示有变更的文件\n​\t\t\t$ git status\n​\t\t# 显示当前分支的版本历史\n​\t\t\t$ git log\n​\t\t# 显示commit历史，以及每次commit发生变更的文件\n​\t\t\t$ git log --stat\n​\t\t# 搜索提交历史，根据关键词\n​\t\t\t$ git log -S [keyword]\n​\t\t# 显示某个commit之后的所有变动，每个commit占据一行\n​\t\t\t$ git log [tag] HEAD --pretty=format:%s\n​\t\t# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n​\t\t\t$ git log [tag] HEAD --grep feature\n​\t\t# 显示某个文件的版本历史，包括文件改名\n​\t\t\t$ git log --follow [file]\n​\t\t\t$ git whatchanged [file]\n​\t\t# 显示指定文件相关的每一次diff\n​\t\t\t$ git log -p [file]\n​\t\t# 显示过去5次提交\n​\t\t\t$ git log -5 --pretty --oneline\n​\t\t# 显示所有提交过的用户，按提交次数排序\n​\t\t\t$ git shortlog -sn\n​\t\t# 显示指定文件是什么人在什么时间修改过\n​\t\t\t$ git blame [file]\n​\t\t# 显示暂存区和工作区的代码差异\n​\t\t\t$ git diff\n​\t\t# 显示暂存区和上一个commit的差异\n​\t\t\t$ git diff --cached [file]\n​\t\t# 显示工作区与当前分支最新commit之间的差异\n​\t\t\t$ git diff HEAD\n​\t\t# 显示两次提交之间的差异\n​\t\t\t$ git diff [first-branch]...[second-branch]\n​\t\t# 显示今天你写了多少行代码\n​\t\t\t$ git diff --shortstat "@{0 day ago}"\n​\t\t# 显示某次提交的元数据和内容变化\n​\t\t\t$ git show [commit]\n​\t\t# 显示某次提交发生变化的文件\n​\t\t\t$ git show --name-only [commit]\n​\t\t# 显示某次提交时，某个文件的内容\n​\t\t\t$ git show [commit]:[filename]\n​\t\t# 显示当前分支的最近几次提交\n​\t\t\t$ git reflog\n​\t\t# 从本地master拉取代码更新当前分支：branch 一般为master\n​\t\t\t$ git rebase [branch]')]),t._v(" "),e("h5",{attrs:{id:"八、远程同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#八、远程同步"}},[t._v("#")]),t._v(" 八、远程同步")]),t._v(" "),e("p",[t._v("​\t\t$ git remote update  --更新远程仓储")]),t._v(" "),e("p",[t._v("​\t下载远程仓库的所有变动")]),t._v(" "),e("p",[t._v("​\t\t\t$ git fetch [remote]")]),t._v(" "),e("p",[t._v("​\t显示所有远程仓库")]),t._v(" "),e("p",[t._v("​\t\t\t$ git remote -v")]),t._v(" "),e("p",[t._v("​\t显示某个远程仓库的信息")]),t._v(" "),e("p",[t._v("​\t\t\t$ git remote show [remote]")]),t._v(" "),e("p",[t._v("​\t增加一个新的远程仓库，并命名")]),t._v(" "),e("p",[t._v("​\t\t\t$ git remote add [shortname] [url]")]),t._v(" "),e("p",[t._v("​\t取回远程仓库的变化，并与本地分支合并")]),t._v(" "),e("p",[t._v("​\t\t\t$ git pull [remote] [branch]")]),t._v(" "),e("p",[t._v("​\t上传本地指定分支到远程仓库")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push [remote] [branch]")]),t._v(" "),e("p",[t._v("​\t强行推送当前分支到远程仓库，即使有冲突")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push [remote] --force")]),t._v(" "),e("p",[t._v("​\t推送所有分支到远程仓库")]),t._v(" "),e("p",[t._v("​\t\t\t$ git push [remote] --all")]),t._v(" "),e("h5",{attrs:{id:"九、撤销"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#九、撤销"}},[t._v("#")]),t._v(" 九、撤销")]),t._v(" "),e("p",[t._v("恢复暂存区的指定文件到工作区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git checkout [file]")]),t._v(" "),e("p",[t._v("恢复某个commit的指定文件到暂存区和工作区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git checkout [commit] [file]")]),t._v(" "),e("p",[t._v("恢复暂存区的所有文件到工作区")]),t._v(" "),e("p",[t._v("​\t\t\t$ git checkout .")]),t._v(" "),e("p",[t._v("重置暂存区的指定文件，与上一次commit保持一致，但工作区不变")]),t._v(" "),e("p",[t._v("​\t\t\t$ git reset [file]")]),t._v(" "),e("p",[t._v("重置暂存区与工作区，与上一次commit保持一致")]),t._v(" "),e("p",[t._v("​\t\t\t$ git reset --hard")]),t._v(" "),e("p",[t._v("重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变")]),t._v(" "),e("p",[t._v("​\t\t\t$ git reset [commit]")]),t._v(" "),e("p",[t._v("重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致")]),t._v(" "),e("p",[t._v("​\t\t\t$ git reset --hard [commit]")]),t._v(" "),e("p",[t._v("重置当前HEAD为指定commit，但保持暂存区和工作区不变")]),t._v(" "),e("p",[t._v("​\t\t\t$ git reset --keep [commit]")]),t._v(" "),e("p",[t._v("新建一个commit，用来撤销指定commit")]),t._v(" "),e("p",[t._v("后者的所有变化都将被前者抵消，并且应用到当前分支")]),t._v(" "),e("p",[t._v("​\t\t\t$ git revert [commit]")]),t._v(" "),e("p",[t._v("暂时将未提交的变化移除，稍后再移入")]),t._v(" "),e("p",[t._v("​\t\t\t$ git stash\n​\t\t\t$ git stash pop")]),t._v(" "),e("h5",{attrs:{id:"十、其他"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#十、其他"}},[t._v("#")]),t._v(" 十、其他")]),t._v(" "),e("p",[t._v("​\t\t# 生成一个可供发布的压缩包\n​\t\t\t$ git archive")]),t._v(" "),e("h3",{attrs:{id:"实际步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实际步骤"}},[t._v("#")]),t._v(" 实际步骤")]),t._v(" "),e("p",[t._v("新建代码库：git clone https://.........")]),t._v(" "),e("p",[t._v("进入当前创建clone进入的文件夹：")]),t._v(" "),e("p",[t._v("将地址添加在origin上：git remote add origin https://............")]),t._v(" "),e("p",[t._v("如果origin已经存在，则先移除然后再添加：git remote rm origin")]),t._v(" "),e("p",[t._v("再添加：git remote add origin https://............")]),t._v(" "),e("p",[t._v("然后添加当前目录的所有文件到暂存区：git add .")]),t._v(" "),e("p",[t._v("然后提交暂存区到仓库区：git commit -m 文字")]),t._v(" "),e("p",[t._v("取回远程仓库的变化，并与本地分支合并(将服务器上的内容拉下来)：git pull origin master")]),t._v(" "),e("p",[t._v("如果取回失败，则执行：git config pull.rebase true")]),t._v(" "),e("p",[t._v("然后将暂存区的以分支形式上传：git push origin master:分支名")]),t._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5Cyyh%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211123194951313.png",alt:"image-20211123194951313"}})]),t._v(" "),e("p",[t._v("git fetch命令\n用于从另一个存储库下载对象和引用。远程跟踪已更新分支（git术语叫commit），需要将这些更新取回本地，这时就要用到git fetch命令。\n语法：git fetch <远程主机名>。例如：git fetch orgin master，表示取回origin主机的master分支。更新所有分支，命令可以简写为git fetch。")]),t._v(" "),e("p",[t._v("git pull命令\n用于取回远程主机某个分支的更新，再与本地的指定分支合并。这时你可能已经真正明白为什么会出现拉取失败的原因了，原因就在于拉取之后的代码合并失败造成的。\n语法：git pull <远程主机名><远程分支名>:<本地分支名>。例如：git pull origin next:master，表示取回origin主机的next分支，与本地的master分支合并。如果远程分支（next）要与当前分支合并，则冒号后面的部分可以省略。")]),t._v(" "),e("p",[t._v("git reset命令\n语法：git reset [- -hard|soft|mixed|merge|keep][或HEAD]，将当前的分支重新设置到指定的commit id或者HEAD，其中HEAD是默认路径。其中hard、soft、mixed、merge、keep是设置的模式。通常使用- -hard，表示自commit id以来，工作目录中的任何改变都被丢弃，并把HEAD指向commit id。\n————————————————")])])}),[],!1,null,null,null);i.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{601:function(t,e,v){"use strict";v.r(e);var _=v(13),s=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"微任务和宏任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微任务和宏任务"}},[t._v("#")]),t._v(" 微任务和宏任务")]),t._v(" "),v("p",[t._v("任务流:每一行代码称之为一个任务，命名函数属于任务流的内容")]),t._v(" "),v("p",[t._v("执行函数时，会开启一个新的任务空间，执行函数中的任务，执行完之后进行释放，然后执行下面的任务流")]),t._v(" "),v("p",[v("strong",[t._v("宏任务")]),t._v("：当整个任务列执行完毕（页面加载完毕）之后再去执行")]),t._v(" "),v("p",[t._v("Promise里面的回调函数是一个即时即执行的函数，then里面的回调函数在执行resolve时才会被触发")]),t._v(" "),v("p",[t._v("每个script都是一个任务流，所有script组成任务列。")]),t._v(" "),v("p",[t._v("当整个任务列执行完毕之后，开启一个新的任务流去执行宏任务。")]),t._v(" "),v("p",[v("strong",[t._v("微任务")]),t._v("：每个任务流最后执行：await；promise的then或catch方法中的回调函数")]),t._v(" "),v("p",[v("strong",[t._v("宏任务")]),t._v("：下一个任务列的最前面执行")]),t._v(" "),v("p",[t._v("setTimeout(function(){},2000)：任务流执行时，先计时，setTimeout()先完成谁就先开启新的任务列，依次向后创建任务列，等待当前整个任务列执行之后，再依次执行创建的任务列。")]),t._v(" "),v("p",[t._v("优先触发宏任务，然后执行当前任务列的微任务，执行完当前任务列之后，再去执行下一个任务列的任务")]),t._v(" "),v("p",[t._v("连续promise的then()执行时，会每执行三次向任务列流的尾部添加没有执行的后续then()里面的微任务。")]),t._v(" "),v("p",[t._v("每次执行promise.resolve().then()都会在任务流尾部添加微任务")]),t._v(" "),v("p",[t._v("await:后不是promise时，会把当前await后的执行后，后面的会将其放在最后执行，在任务列最后执行。")]),t._v(" "),v("p",[t._v("await：后是promise时，")]),t._v(" "),v("p",[t._v("1.当promise后有then时，会将await在当前的块作用域await代码后面的所有代码最后执行（在任务列）")]),t._v(" "),v("p",[t._v("2.当promise后没有then时，会将promise执行完之后，将当前作用域promise之后放在任务列最后执行")])])}),[],!1,null,null,null);e.default=s.exports}}]);
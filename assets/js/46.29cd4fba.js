(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{611:function(e,r,t){"use strict";t.r(r);var o=t(13),n=Object(o.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"flux"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flux"}},[e._v("#")]),e._v(" Flux")]),e._v(" "),t("p",[e._v("Flux 是一种 架构思想，简单来讲 就是: 状态提升到全局Store + Store内容分发给组件 + 组件交互updateStore然后更新组件。 就是这样一种 通过全局store同一管理数据(从而实现组件间数据共享)的架构思想。")]),e._v(" "),t("p",[e._v("redux与react-redux\n基于这种思想，社区里已有各种各样成型的解决方案，其中，redux是通用性比较强的方案(兼容原生和绝大部分框架); 但它的使用较为麻烦，在react项目里，一般用 redux + react-redux + 配置中间件(根据项目需要配置) 这样的方式。 比如 dva = redux + react-redux + redux-saga + router （耦合了router也是dva的诟病所在）; 在hooks出现之后，react提供了 useContext这样的钩子，实现了redux的功能。 react-redux 的核心：Provider 与 connect")]),e._v(" "),t("p",[e._v("Provider和connect的底层原理\nProvider容器组件底层: 把store打入 contextconnect; 高阶组件底层： 从context拿到store，然后打入到参数组件的props;")]),e._v(" "),t("p",[e._v("什么是高阶组件？ 高阶组件：接受一个组件为参数，return 出一个新的组件； 高阶函数：就是一个函数，接受一个函数为参数。\nredux的核心：\ncreateStore 与 disPatchcreateStore： 创建store\ndisPatch： 更新store的方法disPatch的规范/更新store的流程\nreact-redux流程\n状态提升到全局与分发\ncreateStore创建全局状态仓库\nProvider和connnect进行状态的分发\n状态更新\ndisPatch 一个 action （action就是一个对象，形如{type:'xxx',...prarams}）,基于action.type,触发对应的reducer（reducer是具体更新store的方法，纯函数）逻辑，从而更新store;")])])}),[],!1,null,null,null);r.default=n.exports}}]);